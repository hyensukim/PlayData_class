2023.10.06
- SI와 sevice 기업 차이
- 녹화 강의
- 노션을 통한 문서화
- 대규모 트레픽 처리(멀티 프로세싱, 멀티 쓰레딩)
- Mybatis와 JPA를 함께 수업
- CI/CD
- 대규모 트레픽 : 스트레스 테스트 툴
- Redis 라이브러리
- 깃허브(issue, porojects), jira, git-flow(Conflict 방지하기 위한 브렌치 전략)
- 워터풀 & 애자일
- GWT 패턴(Test 코드)
- SOLID 원칙, 디자인 패턴 등
- modern 자바(객체지향 아키텍처, )
- MSA 둥 현업에서 사용하는 아키텍처
- 자소서 및 현업자 질문
- 스프링 입문을 위한 자바 객체 지향의 원리와 이해(추천도서)

MSA

Java
Spring
JPA
HTTP
CS 면접
DDD 관련 지식
MySQL

1. Modern Java

기술 스펙에 대해서 설명할 때, 반대 방식의 단점을 더 부정적으로 보았기 때문에, 현재 스펙을 사용하였다.
방법론도 마찬가지, 둘 다 장단점이 있으나 그 중에서 어떤 것이 합당한지를 따져봐야 한다.

절차 지향 언어(C언어) VS 객체 지향 언어
절차 지향 언어
포인터 , 구조체

1)객체 지향 언어(프로그래밍 하는 방법론)
* 절차지향에서 메서드를 외부에서 구조체를 통해 정의하였으나, 관리하려다 보니 내부에서 하나로 관리하는 것이 좋으니깐, 클래스가 나오고 객체지향 방법이 대두됨
* 클래스
- 필드(변수) : 객체의 상태
- 메서드(함수) 
	- 객체의 행동
	- 메서드는 필드에 의존
* 객체지향 프로그래밍은 테스트에 용이하다
* 객체 지향적인 프로젝트 구조 
- 구분 : 인터페이스 사용 유무

* 오류(휴먼에러) 및 유지보수가 편리하고 그만큼 확장성이 쉽다.
* 예제 구조
객체 지향 X
Client  -> FakeMessageSender
	-> RealMessageSender

* 객체지향적인 프로그래밍을 위해 인터페이스를 중간에 계층으로 추가해주어, 추상화된 단계를 추가해준다.(설계)
SOLID원칙(DIP - 의존역전원칙 / )
Client -> MessageSender <-- FakeMessageSender
			<-- RealMessageSender

2) 클래스와 상속
*상속과 다형성

#debugger#
	break 포인트(중단점)를 지정.
	F8 사용하게 되면, 행마다 변수의 타입에 따라 기본형은 어떤값인지, 참조형은 어떤 인스턴스인지 확인이 가능하다.
- 상속은 extends 키워드로 진행할 수 있습니다.

- 상속을 전제로 부모타입 변수에는 부모타입이나 자식타입의 변수를 모두 대입할 수 있습니다.

- 다만, 부모타입으로는 다형성적으로 대입된 객체가 자식타입이어도 부모측 자원만 호출가능합니다.
- 메모리적인 구조로 보면, 자식 타입 인스턴스 안에는 부모 타입 객체와 자식 타입 객체 2개가 생성된다.
  변수가 부모 타입인 경우, 자식 타입 인스턴스 안에 부모 타입 객체만 담기게 되어, 자식 타입 객체 안에 요소를 사용할 수 없게 되는 것이다.

* 메서드 오버라이딩(재정의) : 위의 자식 타입에서도 자식타입측 자원을 사용이 가능하도록 하기 위해 사용.(다형성의 확장)
** 부모클래스에서 상속받은 메서드를 자식에서 재정의하는 것.

** 메서드의 시그니처는 같아야 함
- 시그니처는 리턴타입, 메서드의 명칭, 요구하는 파라미터 등을 의미함.
- @Override : 메서드가 재정의 목적으로 정의되었다고 표시해줘야, 오버라이딩 되었는지 여부를 컴파일 시점에서 파악이 가능하기 때문에, 유지보수가 용이하다.

** 자식 타입 인스턴스에서 재정의 시, 부모 타입 클래스에 정의된 메서드 대신, 자식 타입 클래스에 정의된 메서드가 호출된다.
- 메모리적인 구조로 보면, 자식 타입 안에 부모 인스턴스의 메서드 호출을 하되, 재정의 유무를 확인 후 재정의 되어 있는 경우, 자식 인스턴스의 메서드를 재호출하게 된다.

* 메서드 오버로딩
- 메서드명이 같아도 요구 파라미터가 다르다면, 호출 단계에서 구분 가능.
- 같은 메서드명에 호출 파라미터의 개수나 타입이 다르면 허용.
- 단, 파라미터의 종류나 개수가 같고 리턴자료만 다른것으로는 구분 불가.

* 상속 관련 시 주의사항
- 객체지향 프로그램이에서 가장 중점이 되어야 하는것은 유지보수 및 확장성, 유연성이 높아야 한다.
- 확장성, 유연성이 높으려면 추상도가 높아야 한다.(추 : 꺼내다, 상 : 형상 -> 몇가지 특징만 뽑아서 모호하게 만드는것)
- 즉, 모호할수록 자유도가 더 올라가게 된다.
- 따라서 일반적으로 전략 패턴 구성을 활용하여 메서드를 재사용하는 것이 좋다.
- 왜냐하면, 부모타입으로 할 수 있는 일은 자식타입으로도 할 수 있도록 해야 한다.(리스코프 치환 원칙)

3) 추상클래스와 인터페이스
* 추상 클래스
- abstract
- 인스턴스 생성 불가(추상 메서드를 직접 재정의 해주면 가능)
- 일반적으로 하나 이상의 추상메서드를 포함

* 차이점 
- 추상 클래스 안에서는 필드 및 일반 메서드 정의가 가능.
- 인터페이스는 필드는 정의가 불가하고, 상수만 정의가 가능, 메서드도 추상 메서드만 정의 가능하다.(디폴트 메서드 제외)
- 추상클래스는 클래스이므로, 자식입장에서 1개만 상속이 가능하지만, 인터페이스의 경우 하나의 구현(자식) 클래스에서 여러개 구현(상속)이 가능하다.

* 일반적인 상황에서 인터페이스를 사용하는 경우가 많다.
- 추상클래스가 인터페이스에 비해 구체적이기 때문이다.

* 추상클래스를 인터페이스대신 사용하는 경우는 다음 경우입니다.
- 인스턴스 변수(필드)를 정의해야 하는 경우 : 인터페이스는 상수만 정의 가능
- 생성자가 필요한 경우 : 인터페이스는 내부에 생성자 정의 불가
- Object 클래스의 메서드를 오버라이딩 하고 싶은 경우

4) Enum 클래스(이넘)



  