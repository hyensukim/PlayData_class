# 2. 객체지향적 코드 작성하기

## 🎇 기본 지식

### 🐼 3Tier Layer Architecture

> Controller - Service - Repository

#### **cf**

자바(메모리, RAM) - DBMS(저렴,디스크, HDD, SSD, 영속계층(영속성 컨텍스트))  --> 예외, 레디스(In memory, 비쌈)

#### **기본 구조**

Controller : 사용자 요청 처리, 사용자 관점의 계층

Repository : 쿼리문 호출, 컴퓨터 관점 계층

- Service layer(계층) : 사람 관점의 계층과 컴퓨터 관점의 계층을 구분하기 위해 중간 역할을 해주는 계층.

### 🐼 Domain Drive Development(DDD)

> Domain
>
> Presentation - Application - Infrastructure

![img]()

#### Domain

엔티티 클래스(세부적인 예외)

영속 계층의 인터페이스

#### Presentation

컨트롤러  DTO 글로벌 예외처리

#### Application

DTO

#### infraStructure

외부적 호출(인터페이스) - 구현체(내부적 호출)

저수준 컴포넌트 -의존 -> 고수준 컴포넌트

도메인(최고) > 서비스 > 컨트롤러 > 영속성 인터페이스 > 영속성(저수준) 구현체

## 🎇 if문을 최대한 억제하기

많은 if문은 개발자의 가독성을 떨어뜨린다. if문을 직면 시, 2가지 이상의 경우를 나눠 다른 결과를 생각해야 하기 때문이다.

> if문을 줄일 수 있는 방법

- early return : 빠른 리턴
- 미리 유효성 검증 후 연산
- enum 안으로 연산 집어넣기

따라서 생성 시점에 아예 유효성 검사를 하는 것이 좋다.

## 🎇 Getter,Setter

### DTO를 사용하는 이유

레이어(layer)간 이동 시, 사용하는 객체(데이터 전송 객체)

여기서 레이어란... 컨트롤러 레이어 또는 서비스 레이어 등을 말한다.

DTO는 엔티티의 정보를 캡슐화하기 위해 별도로 데이터를 전송할 객체를 사용한다.

### getter가 작성되었을 때의 문제

클라이언트 코드에서 커맨드 코드 내부를 쉽게 추론하도록 만들어주는 문제가 있다.

따라서 getter 대신 특정 비지니스 로직을 바로 집어넣는 방법이 더 좋다.

캡슐화는 이런 방향으로 어떤 작업을 할 수 있지는 알려주지만, 그 작업이 어떤 방식으로 진행되는지는 숨기는 방향으로 간다.

이를 결합도와 응집도라는 단어로 설명 가능하다.

- 결합도 : 두 클래스간에 영향을 주는 것이 많아서(하나의 클래스에 다른 클래스 요소를 과하게 참조해서) 하나의 변경이 다른 클래스에게도 크게 영향을 주는 경우
- 응집도 : 하나의 도메인에서 활용하는 로직을 최대한 하나의 클래스 내부에 모아두는 경우

객체 지향적인 프로그래밍을 위해 ***결합도**는 낮추고* ***응집도**는 높여야* 좋다고 한다.

### 생성자 주입이 좋고 setter를 되도록 쓰지 말아야 하는 이유

모든 필드의 초기화하지 않게 되는 인적 오류를 방지하여, 생성자 주입을 강요하는 것이 좋다.

불완전한 인스턴스의 생성을 억제할 수 있다는 것이 생성자 주입의 좋은 점이다.

그래서 외부와의 접점이 있는 클래스를 DTO로 먼저 사용 후 내부적으로 따로 사용하는 Entity 클래스를 이용하는 것이 좋은 이유이다.
